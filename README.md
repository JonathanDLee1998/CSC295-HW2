Binary makes a little bit more sense to me, because you never know where the item you're looking is going to be. Going in order seems smart if you know whatever you're looking for is going to be close to the beginning. I struggled with this a lot. I find coding confusing and upsetting, but somehow still interesting. Using it to find what was needed took a long time, and much stress but eventually it started to work. I had to ask around and utilize ChatGpt to get it to work. When we made a number guessing game i found the best way to get a number from between 1 and 100 was to guess 50. The game would tell me if I'm too high or too low. From there I would guess 25 or 75 after getting a hint. Binary is just like this, and since I've used this in real life, I didn't see why I shouldn't now. A linear search is a straightforward and simple algorithm used to find a specific element in a list or an array. The algorithm works by sequentially checking each element of the list until the desired element is found or the end of the list is reached. Linear search is easy to implement and understand, making it a fundamental concept in computer science and programming. While linear search is useful for small and unsorted lists due to its simplicity, its inefficiency for large and sorted data sets makes it less practical for many real-world applications. More advanced algorithms, such as binary search, hash tables, or tree-based searches, often provide better performance and should be considered when working with larger or more complex data sets. A binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing the search interval in half. Binary search is widely used in computer science due to its efficiency and simplicity when dealing with sorted datasets. Binary search, while efficient, has several downsides. It requires the data to be sorted, necessitating additional time to sort unsorted lists. Maintaining a sorted list can be costly, especially with frequent insertions and deletions. Compared to linear search, binary search is more complex to implement and can be error-prone, particularly with edge cases. It is also inefficient for linked lists because accessing the middle element takes linear time, negating the algorithm's advantages. Recursive implementations of binary search can cause stack overflow for very large lists. Furthermore, binary search is best suited for arrays and lists with efficient random access and does not adapt well to changes in data, as insertions and deletions require re-sorting, making it less efficient for dynamic datasets. 
